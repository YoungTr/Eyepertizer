# 一个好的移动端日志框架是怎么炼成的

对于移动应用来说，日志库是必不可少的基础设施。线上出现问题时，往往需要回捞日志，协助排查并解决问题。

那么一个好的日志框架需要具备哪些特性呢？

* 高效性：不能影响性能，导致卡顿
* 完整性：存储传输过程中不能丢失
* 集中性：各类日志信息统一收集
* 安全性：不能被随意破解
* 便利性：回捞方便、前端展示便于定位和分析

### 高效性

日志模块作为底层基础库，首先要保证流畅性，对上层的性能影响必须尽量小，但是日志写操作是非常频繁的，如果在 Java 中操作这些数据，非常容易发生大量的 GC，频繁的 I/O 操作也容易导致 CPU 占用过高，甚至出现 CPU 峰值，从而影响应用性能，发生卡顿现象。

数据从程序写入到磁盘的过程中，其中牵涉到两次数据拷贝：一次是用户控件拷贝到内核空间的缓存，一次是回写时内核空间的缓存到硬盘的拷贝。当发生回写时也涉及到了内核空间和用户空间频繁切换。

![](./pics/write.jpg)

Java 实现最简单的方案主要性能瓶颈是出现在频繁写文件上，那是否可以先把日志缓存到内存中，当到一定大小时才进行后续操作。

![buffer](./pics/buffer.jpg)

内存缓存暂时能解决频繁 I/O 导致的问题，但这个方案有一个问题：**丢日志**。

### 完整性

使用内存缓存时，在杀进程、crash 的时候，容易丢失内存数据，从而导致日志的丢失。

理想情况：

> 当程序 crash 时，crash 捕捉模块捕捉到 crash，然后调用日志接口把内存中的日志刷新的文件中。但是在实际中程序被系统杀死不会有事件通知，而且很多异常退出（如 nativ crash），crash 捕捉模块并一定能捕捉到。而这种情况恰恰是跟进的重点，没有 crash 堆栈辅助定位，丢日志的问题在这个时候就显得尤为凸显。

#### mmap

mmap 是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，使得应用程序处理映射部分如同访问主内存。

![mmap](./pics/mmap.png)

使用 mmap 几乎和直接写内存一样的性能，避免了写文件的数据拷贝，避免了内核空间和用户空间的频繁切换，而且 mmap 不会丢失日志，回写时机基本可控。

> 这里有个兜底操作，如果 mmap 初始化失败，会开辟一块堆空间来做日志缓存，小概率事件。

### 安全性

日志的存储必然是**不允许使用明文的**，往往会对数据进行**压缩和加密**。但是*先加密再压缩*还是*先压缩再加密*效率比较高呢？

很明显是**先压缩再加密**效率比较高，这样会减少 mmap 占用的内存大小， 每写一行日志日志模块就必须进行压缩和加密。 

但是如果把 app 的生命周期作为一个压缩单位，如果这个压缩单位中有数据损坏，那么后面的日志也就解压不出来了。所以可以把一定大小的作为一个压缩单位，这样即使压缩单位中有部分数据损坏，并不会影响这个单位中损坏数据之前的日志解决，也不会影响其他单位中的数据解压。

> 流式压缩耗时本身较小，几乎不会对性能造出影响，最关键的是，多条日志同时压缩会导致 CPU 曲线短时间内极速升高，进而会导致程序卡顿，而流式压缩是把时间分散在整个生命周期内，CPU 的曲线相对更平滑。





### 参考

[mmap wiki](https://en.wikipedia.org/wiki/Mmap)

[认真分析mmap：是什么 为什么 怎么用](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

[微信mars 的高性能日志模块 xlog](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg%3D%3D&mid=2653578220&idx=3&sn=5691bdd82ae0715ab12fd6b849f74aee&chksm=84b3b1ebb3c438fddf86bf74e232fa14222932ebd6d6439bed04ad17d5e64e9270d4ab460f64&scene=4)

[美团移动端基础日志库——Logan](https://tech.meituan.com/2018/02/11/logan.html)

[数据流压缩原理（Deflate压缩算法、gzip、zlib）](https://www.codenong.com/cs106685915/)



